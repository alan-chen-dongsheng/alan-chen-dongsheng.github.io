---
title: IREE compielr Leaning object
date: '2026-01-25'
tags:
    - IREE
    - "AI infra"
draft: false
summary: "IREE的Pipline各个阶段的职责"
---



# IREE的Pipline各个阶段的职责

```c++
enum class IREEVMPipelinePhase { Start, Input, ABI, Preprocessing, GlobalOptimization, DispatchCreation, Flow, Stream, ExecutableSources, ExecutableConfigurations, ExecutableTargets, HAL, VM, End, };
```



### **1. Start**

- **作用**：初始化阶段，通常会设置编译的初始状态。
- **解决的问题**：在编译流程的开始，主要是设置基本的环境和初始化必要的资源，为后续的各个阶段做准备。

------

### **2. Input**

- **作用**：处理输入阶段，负责解析输入模型并将其转化为 IREE 可理解的中间表示（IR）。
- **解决的问题**：输入模型可能来自 TensorFlow、JAX、ONNX 等不同框架，因此需要解析并将其统一转换成适合后续处理的中间表示。这个阶段解决了输入数据格式统一的问题。

------

### **3. ABI**

- **作用**：执行 ABI 相关的处理，即将输入数据转化为目标平台能够理解的二进制接口。
- **解决的问题**：这个阶段确保了数据能够以正确的格式传递到目标硬件，并且进行适配，使得后续的编译过程能够适应不同的硬件架构和目标平台。

------

### **4. Preprocessing**

- **作用**：进行预处理阶段，主要进行输入数据的转换、解析和一些初步的优化（如常量折叠、死代码移除等）。
- **解决的问题**：预处理阶段主要解决了输入数据需要被转换为更适合后续处理的形式，并对输入进行优化，减少不必要的计算。

------

### **5. GlobalOptimization**

- **作用**：进行全局优化，优化整个模型或程序的结构。
- **解决的问题**：全局优化的目标是对整个程序进行更高层次的优化，例如算子融合、内存布局优化等。这个阶段的目标是减少计算量和内存开销，提升性能。

------

### **6. DispatchCreation**

- **作用**：创建 **dispatch**，即将计算分配到目标硬件的任务。
- **解决的问题**：这个阶段解决了如何将计算任务划分并调度到具体的硬件单元（如 CPU、GPU、NPU 等）。它生成的 dispatch 将确保计算能够按正确的顺序和方式在硬件上执行。

------

### **7. Flow**

- **作用**：负责计算流的构建，确保数据和任务按正确的流动路径执行。
- **解决的问题**：流阶段主要是解决计算任务之间的依赖关系，确保数据流动和任务调度的正确性。例如，解决如何在硬件设备之间传输数据、如何在执行过程中处理内存和计算的依赖。

------

### **8. Stream**

- **作用**：进行 **流式执行**，即按流的方式执行计算，进行硬件资源的管理。
- **解决的问题**：流阶段负责在硬件上并行执行计算任务，确保计算和数据流的高效性。它主要解决了如何高效地调度任务以及管理硬件资源（如内存、计算单元）。

------

### **9. ExecutableSources**

- **作用**：生成 **可执行源**，即生成可以编译和执行的源代码。
- **解决的问题**：将计算图或 IR 转化为可以执行的源代码，这些源代码可以进一步编译成目标平台的可执行文件。此阶段解决了如何从中间表示生成可执行代码的转换问题。

------

### **10. ExecutableConfigurations**

- **作用**：生成 **可执行配置**，为目标平台的执行做好准备。
- **解决的问题**：此阶段主要负责生成目标平台需要的配置文件，包括硬件设置、内存布局、调度策略等。它解决了将执行环境配置好，以确保代码能够在目标硬件上顺利运行。

------

### **11. ExecutableTargets**

- **作用**：指定生成的可执行文件的 **目标平台**。
- **解决的问题**：该阶段指定最终生成的可执行文件的目标平台信息，如 CPU 架构、指令集等。它确保生成的代码能够在特定的硬件上运行。

------

### **12. HAL**

- **作用**：处理与 **硬件抽象层（HAL）** 的交互。
- **解决的问题**：此阶段负责将生成的代码与硬件抽象层接口对接，确保生成的执行单元可以与实际硬件进行通信和执行。它解决了硬件与 IREE 的抽象层之间的适配问题。

------

### **13. VM**

- **作用**：将最终的执行单元转换为 **虚拟机（VM）** 能够理解和执行的格式。
- **解决的问题**：IREE 提供了一个虚拟机（VM）执行环境，该阶段负责将中间表示转换为虚拟机能够执行的格式。它解决了如何在 IREE 虚拟机上执行计算的问题。

------

### **14. End**

- **作用**：结束阶段，标志着整个编译管线的完成。
- **解决的问题**：这是编译管线的结束标志，表示所有阶段已经完成，最终的可执行文件或执行单元已经生成。

------

### **总结：**

这些阶段是 IREE 虚拟机编译管线的各个组成部分，每个阶段都专注于解决特定的编译和执行问题：

1. **Start**: 初始化环境
2. **Input**: 解析输入模型
3. **ABI**: 适配数据为目标平台的 ABI 格式
4. **Preprocessing**: 对输入数据进行预处理和初步优化
5. **GlobalOptimization**: 对整个程序进行全局优化
6. **DispatchCreation**: 创建硬件调度任务
7. **Flow**: 构建计算任务流
8. **Stream**: 高效地在硬件上执行计算任务
9. **ExecutableSources**: 生成可执行源代码
10. **ExecutableConfigurations**: 生成目标平台的配置文件
11. **ExecutableTargets**: 指定目标硬件平台
12. **HAL**: 与硬件抽象层交互
13. **VM**: 转换为虚拟机执行的格式
14. **End**: 编译结束

每个阶段解决了从输入到硬件执行的不同问题，确保整个编译过程的高效和正确。



# 新人学习建议

## 1) 代码库整体定位与目标

IREE（Intermediate Representation Execution Environment）是一个基于 MLIR 的端到端编译器与运行时系统，用于将 ML 模型降低到统一 IR，并覆盖从数据中心到移动/边缘设备的部署需求。

------

## 2) 代码库整体结构（顶层视角）

开发者概览明确列出了核心目录的职责，建议新人首先从这些入口理解整体分层：

- **/compiler/**：MLIR 方言、LLVM 编译 passes、模块翻译等核心编译器代码。
- **/runtime/**：IREE 运行时实现，包括 VM 与 HAL 驱动。
- **/integrations/**：与其他框架（如 TensorFlow）的集成层。
- **/tests/**：端到端 compiler→runtime 工作流测试。
- **/tools/**：开发工具集（如 `iree-compile`, `iree-run-module` 等）。
- **/samples/**：示例模型与相关材料（另有 iree-experimental 仓库）。

------

## 3) 编译器与运行时的关键子目录（推荐重点理解）

### 编译器内部结构（/compiler/src/...）

- **API/**：C API 对外接口。
- **Codegen/**：Kernel 代码生成。
- **Dialect/**：IREE 自定义 MLIR 方言（Flow/HAL/Stream/VM 等）。
- **InputConversion/**：从输入方言到 IREE IR 的转换与预处理。

### 运行时内部结构（/runtime/src/iree/...)

- **base/**：运行时基础类型与工具。
- **hal/**：硬件抽象层（HAL），对接各类硬件/软件后端。
- **schemas/**：数据存储格式定义（FlatBuffers）。
- **task/**：多线程任务系统。
- **tooling/**：测试与开发工具的运行时辅助代码。
- **vm/**：IREE 虚拟机字节码执行器。

------

## 4) 新人需要了解的“重要内容/工具”

这些工具和流程构成编译器/运行时的核心使用方式：

- **`iree-opt`**：用于单步运行编译器 passes，常见于 MLIR 测试与调试。
- **`iree-compile`**：主要编译驱动，将 MLIR 转换为 IREE 模块。
- **`iree-run-module`**：运行编译后模块，适合端到端验证与示例执行。





